# 参数传递
	- 每次调用函数时都会重新创建它的形参，并用传入的实参对形参进行初始化；
	- 如果形参是引用类型，它将绑定到对应的实参上，否则将实参的值copy后赋值给形参；
	- 当形参是引用类型时，我们说它对应的实参被引用传递或者函数被传引用调用；
	- 和其他引用一样，引用形参也是它绑定的对象的别名，也就是说，引用形参是它对应的实参的别名；
	- 当实参的值被copy给形参时，形参和实参是两个相互独立的对象，我们说这样的实参被值传递或者函数被传值调用；

# 传值参数
	- 实参和形参是两个个体，形参的修改不会对实参产生影响；

# 指针形参
	- 指针形参，可以修改指针指向的对象的值，但是指针实参并没有发生改变；
	***C程序猿常常使用指针类型的形参访问函数外部的对象。在C++语言中，建议使用引用类型的形参代替指针***

# 传引用参数
	- 使用引用参数，对引用的修改，其实修改的就是实参的值；

# 使用引用避免copy
	- copy大的类类型对象或者容器对象比较低效，甚至有些类类型（包括IO类型在内）根本就不支持copy。当某种类型不支持copy操作时，函数只能通过引用形参访问该类型的对象；
	- 

# 使用引用参数返回额外的信息
	- 一个函数如果想同时返回多个值，引用形参为我们一次返回多个结果提供了有效的途径

# 数组作为参数 
	- 使用标准库，begin() 和 end()
	- 多传入一个参数，此参数为数组的长度

# 数组引用形参
	```
		void  print(int (&arr) [10])
		{
			for (auto elem : arr)
			{
				cout << elem << endl;
			}
		}
	```
	- &arr 两端的括号必不可少
		* f(int &arr[10])   // 错误：将arr声明成了引用数组
		* f(int (&arr)[10]) // 正确：arr是具有10个整数的整形数组的引用
	- 因为数组的大小是构成数组类型的一部分，所以只要不超过维度，在函数体内就可以放心的使用数组；
	- 但是上面的用法也限制了，print函数的可用性，我们只能将函数作用于大小为10的数组；

# 含有可变形参的函数
	- 使用initializer_list标准库类型；
		* initializer_list<T> lst; 	 // 默认初始化；T类型元素的空列表
		* initializer_list<T> lst{a, b, c...}; // lst的元素数量和初始值一样多； lst的元素是对应初始值的副本；列表中的元素是const
		* lst2(lst) // copy或赋值一个initializer_list对象不会copy列表中的元素； copy后原始列表和副本共享元素
		* lst.size()	 // 列表中元素的数量
		* lst.begin()	 // 返回指向lst中首元素的指针
		* lst.end()	     // 返回指向lst中尾元素下一位置的指针
	- 和vector不一样的是，initializer_list对象中的元素永远是常量值，我们无法修改其中的值
	```
	void errr_msg(initializer_list<string> il)
	{
		for (auto beg = il.beging(); beg != il.end(); ++beg)
		{
			cout << *beg << " " ;
		}
		cout << endl;
	}
	```